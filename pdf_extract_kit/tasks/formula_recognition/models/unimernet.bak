import os
import torch
from PIL import Image
import numpy as np
import cv2
import argparse
from unimernet.common.config import Config
import unimernet.tasks as tasks
from unimernet.processors import load_processor
from pdf_extract_kit.registry import MODEL_REGISTRY

@MODEL_REGISTRY.register('formula_recognition_unimernet')
class FormulaRecognitionUniMERNet:
    def __init__(self, config):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model_dir = config['model_path']
        self.cfg_path = config.get('cfg_path', "pdf_extract_kit/configs/unimernet.yaml")
        self.model, self.vis_processor = self.load_model_and_processor()

    def load_model_and_processor(self):
        args = argparse.Namespace(cfg_path=self.cfg_path, options=None)
        cfg = Config(args)
        cfg.config.model.pretrained = os.path.join(self.model_dir, "pytorch_model.bin")
        cfg.config.model.model_config.model_name = self.model_dir
        cfg.config.model.tokenizer_config.path = self.model_dir
        task = tasks.setup_task(cfg)
        model = task.build_model(cfg).to(self.device)
        vis_processor = load_processor('formula_image_eval', cfg.config.datasets.formula_rec_eval.vis_processor.eval)
        return model, vis_processor

    def predict(self, images):
        results = []
        for image_path in images:
            try:
                raw_image = Image.open(image_path)
            except IOError:
                print(f"Error: Unable to open image at {image_path}")
                continue

            # Convert PIL Image to OpenCV format
            open_cv_image = np.array(raw_image)
            if len(open_cv_image.shape) == 3:
                open_cv_image = open_cv_image[:, :, ::-1].copy()

            # Process and predict
            image = self.vis_processor(raw_image).unsqueeze(0).to(self.device)
            output = self.model.generate({"image": image})
            pred = output["pred_str"][0]
            print(f'Prediction for {image_path}:\n{pred}')

            # Optionally display the image using cv2
            cv2.imshow('Original Image', open_cv_image)
            cv2.waitKey(0)
            cv2.destroyAllWindows()

            results.append(pred)
        return results
